// Generated by Haxe 4.0.0-preview.4+1e3e5e016
(function () { "use strict";
var $hxEnums = {};
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Math.__name__ = true;
var Textures = function(head,segment,fruit) {
	this.head = head;
	this.segment = segment;
	this.fruit = fruit;
};
Textures.__name__ = true;
var SnakeGame = function(width,height,segmentSize,playfieldSize) {
	if(playfieldSize == null) {
		playfieldSize = 20;
	}
	if(segmentSize == null) {
		segmentSize = 20;
	}
	if(height == null) {
		height = 600;
	}
	if(width == null) {
		width = 600;
	}
	this.segmentSize = segmentSize;
	var f = $bind(this,this.create);
	var playfieldSize1 = playfieldSize;
	var tmp = function() {
		f(playfieldSize1);
	};
	this.game = new Phaser.Game(width,height,Phaser.AUTO,"snakedci",{ preload : $bind(this,this.preload), create : tmp, update : $bind(this,this.update)});
};
SnakeGame.__name__ = true;
SnakeGame.main = function() {
	new SnakeGame();
};
SnakeGame.prototype = {
	preload: function() {
		this.game.load.image("background","assets/connectwork.png");
		var head = this.game.make.graphics();
		head.lineStyle(1,16777215,1);
		head.beginFill(13586443,1);
		head.drawRect(0,0,this.segmentSize - 1,this.segmentSize - 1);
		head.endFill();
		var segment = this.game.make.graphics();
		segment.lineStyle(1,16777215,1);
		segment.beginFill(16740363,1);
		segment.drawRect(0,0,this.segmentSize - 1,this.segmentSize - 1);
		segment.endFill();
		var fruit = this.game.make.graphics();
		fruit.lineStyle(1,16720435,1);
		fruit.beginFill(16724804,1);
		fruit.drawRect(0,0,this.segmentSize - 2,this.segmentSize - 2);
		fruit.endFill();
		this._textures = new Textures(head.generateTexture(),segment.generateTexture(),fruit.generateTexture());
	}
	,create: function(playfieldSize) {
		var playfieldWidth = this.segmentSize * playfieldSize;
		this.game.add.tileSprite(0,0,this.game.width,this.game.height,"background");
		var border = this.game.make.graphics();
		border.lineStyle(2,13421772,1);
		border.beginFill(1118481,0.85);
		border.drawRect(0,0,playfieldWidth + 2,playfieldWidth + 2);
		border.endFill();
		var playfieldBorder = this.game.add.sprite(0,0,border.generateTexture());
		var snake = new data_Snake(this.game,this._textures);
		var fruit = this.game.add.sprite(0,0,this._textures.fruit);
		this.playfield = new data_Playfield(this.game,snake,fruit,playfieldWidth);
		this.playfield.x = (this.game.world.width - playfieldWidth) / 2;
		this.playfield.y = (this.game.world.height - playfieldWidth) / 2;
		playfieldBorder.x = this.playfield.x - 2;
		playfieldBorder.y = this.playfield.y - 2;
		var start = playfieldWidth / 2 | 0;
		var _g = 0;
		while(_g < 4) {
			var i = _g++;
			snake.addSegment(start - i * this.segmentSize,start);
		}
		fruit.x = Std.random(playfieldSize) * this.segmentSize + 1;
		fruit.y = Std.random(playfieldSize) * this.segmentSize + 1;
		this.keyboard = this.game.input.keyboard.createCursorKeys();
		this.score = this.game.add.text(10,10,"Score: 0",{ font : "20px Arial", fill : "#ffffff", align : "left", boundsAlignH : "left", boundsAlignV : "top"});
		this.score.health = 0;
		var highScore = this.hiscore == null ? 0 : this.hiscore.health;
		this.hiscore = this.game.add.text(0,0,"Hi-score: " + highScore,{ font : "20px Arial", fill : "#ffffff", align : "right", boundsAlignH : "right", boundsAlignV : "top"}).setTextBounds(this.game.world.width - 150,10,140,20);
		this.hiscore.health = highScore;
		this.movement = new contexts_Movement(this,snake,this.keyboard,{ width : this.playfield.width, height : this.playfield.height});
		this.movement.start();
	}
	,update: function() {
		this.movement.checkDirectionChange();
	}
};
var Std = function() { };
Std.__name__ = true;
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var dci_Context = function() { };
dci_Context.__name__ = true;
var contexts_Collisions = function(game,movement) {
	this.SNAKE = game.playfield.snake;
	this.FRUIT = game.playfield.fruit;
	this.SCORE = game.score;
	this.SCREEN = game.game;
	this.HISCORE = game.hiscore;
	this._game = game;
	this._movement = movement;
	this._segmentSize = game.segmentSize;
};
contexts_Collisions.__name__ = true;
contexts_Collisions.__interfaces__ = [dci_Context];
contexts_Collisions.prototype = {
	checkCollisions: function() {
		this.SNAKE__checkForFruitCollision(this._game.playfield.width);
		this.SNAKE__checkForCollisionWithItself();
	}
	,collides: function(o1,o2) {
		var x1 = Phaser.Math.snapToFloor(o1.x,this._segmentSize);
		var y1 = Phaser.Math.snapToFloor(o1.y,this._segmentSize);
		var x2 = Phaser.Math.snapToFloor(o2.x,this._segmentSize);
		var y2 = Phaser.Math.snapToFloor(o2.y,this._segmentSize);
		if(x1 == x2) {
			return y1 == y2;
		} else {
			return false;
		}
	}
	,waitForGameRestart: function() {
		this._game.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR).onUp.addOnce(($_=this._game.game.state,$bind($_,$_.restart)));
	}
	,SNAKE__segments: function() {
		var _g = [];
		var _g2 = 0;
		var _g1 = this.SNAKE.length | 0;
		while(_g2 < _g1) {
			var i = _g2++;
			_g.push(this.SNAKE.getAt(i));
		}
		return _g;
	}
	,SNAKE__checkForFruitCollision: function(playfieldWidth) {
		if(this.collides(this.SNAKE.getAt(0),this.FRUIT)) {
			this.FRUIT__moveToRandomLocation(playfieldWidth);
		}
	}
	,SNAKE__checkForCollisionWithItself: function() {
		var _gthis = this;
		var snakeSegments = this.SNAKE__segments();
		var head = snakeSegments.shift();
		if(Lambda.exists(snakeSegments,function(s) {
			return _gthis.collides(s,head);
		})) {
			this._movement.stop();
			this.SCREEN__showGameOver();
		}
	}
	,SNAKE__addSegment: function() {
		this._movement.growOnNextMove();
	}
	,FRUIT__moveToRandomLocation: function(playfieldWidth) {
		var _gthis = this;
		while(true) {
			var max = playfieldWidth / this._segmentSize | 0;
			var tmp = Std.random(max) * this._segmentSize;
			this.FRUIT.x = tmp + 1;
			var tmp1 = Std.random(max) * this._segmentSize;
			this.FRUIT.y = tmp1 + 1;
			if(!Lambda.exists(this.SNAKE__segments(),function(s) {
				return _gthis.collides(s,_gthis.FRUIT);
			})) {
				break;
			}
		}
		this.SCORE__increase();
	}
	,SCORE__increase: function() {
		this.SCORE.health += 10;
		this.SCORE.setText("Score: " + this.SCORE.health);
		this.SNAKE__addSegment();
	}
	,SCORE__submitHiscore: function() {
		this.HISCORE__update(this.SCORE.health);
	}
	,HISCORE__update: function(currentScore) {
		this.HISCORE.health = Phaser.Math.max(this.HISCORE.health,currentScore);
		this.waitForGameRestart();
	}
	,SCREEN__showGameOver: function() {
		this.SCREEN.add.text(0,0,"GAME OVER",{ font : "50px Arial", fill : "#ffffff", stroke : "#000000", strokeThickness : 3, align : "center", boundsAlignH : "center", boundsAlignV : "middle"}).setTextBounds(0,-20,this.SCREEN.width,this.SCREEN.height);
		this.SCREEN.add.text(0,0,"Press space to restart",{ font : "20px Arial", fill : "#ffffff", stroke : "#000000", strokeThickness : 2, align : "center", boundsAlignH : "center", boundsAlignV : "middle"}).setTextBounds(0,30,this.SCREEN.width,this.SCREEN.height);
		this.SCORE__submitHiscore();
	}
};
var contexts_Movement = function(game,segments,keyboard,fieldSize) {
	this._growOnNextMove = false;
	this.SEGMENTS = segments;
	this.HEAD = segments.getAt(0);
	this.KEYBOARD = keyboard;
	if(segments.length < 2) {
		throw new js__$Boot_HaxeError("SEGMENTS length must be more than 1.");
	}
	this._fieldSize = fieldSize;
	this._game = game;
	this._movementTimer = game.game.time.create(false);
	var head = segments.getAt(0);
	var body = segments.getAt(1);
	var diffY = Math.abs(body.y - head.y);
	var diffX = Math.abs(body.x - head.x);
	this._wantedDirection = this._currentDirection = diffY < diffX ? body.x > head.x ? Phaser.LEFT : Phaser.RIGHT : body.y > head.y ? Phaser.UP : Phaser.DOWN;
};
contexts_Movement.__name__ = true;
contexts_Movement.__interfaces__ = [dci_Context];
contexts_Movement.prototype = {
	checkDirectionChange: function() {
		this.KEYBOARD__updateDirection();
	}
	,start: function() {
		var _gthis = this;
		this._movementTimer.start();
		var moveEvent = null;
		moveEvent = function() {
			_gthis.HEAD__move();
			new contexts_Collisions(_gthis._game,_gthis).checkCollisions();
			_gthis._movementTimer.add(_gthis.SEGMENTS__moveSpeed(),moveEvent);
		};
		moveEvent();
	}
	,stop: function() {
		this._movementTimer.stop();
	}
	,growOnNextMove: function() {
		this._growOnNextMove = true;
	}
	,dir2Text: function(dir) {
		if(dir == Phaser.UP) {
			return "UP";
		} else if(dir == Phaser.DOWN) {
			return "DOWN";
		} else if(dir == Phaser.LEFT) {
			return "LEFT";
		} else if(dir == Phaser.RIGHT) {
			return "RIGHT";
		} else {
			return "<NOWHERE>";
		}
	}
	,HEAD__move: function() {
		var prevX = this.HEAD.x;
		var prevY = this.HEAD.y;
		var moveDir = this.HEAD__disallowOppositeDir();
		if(moveDir == Phaser.UP) {
			this.HEAD.y -= this.HEAD.height;
		} else if(moveDir == Phaser.DOWN) {
			this.HEAD.y += this.HEAD.height;
		} else if(moveDir == Phaser.LEFT) {
			this.HEAD.x -= this.HEAD.width;
		} else if(moveDir == Phaser.RIGHT) {
			this.HEAD.x += this.HEAD.width;
		}
		this._currentDirection = moveDir;
		if(this.HEAD.x >= this._fieldSize.width) {
			this.HEAD.x = 0;
		} else if(this.HEAD.x < 0) {
			this.HEAD.x = this._fieldSize.width - this.HEAD.width;
		}
		if(this.HEAD.y >= this._fieldSize.height) {
			this.HEAD.y = 0;
		} else if(this.HEAD.y < 0) {
			this.HEAD.y = this._fieldSize.height - this.HEAD.height;
		}
		this.SEGMENTS__moveTo(prevX,prevY);
	}
	,HEAD__disallowOppositeDir: function() {
		if(this._wantedDirection == Phaser.RIGHT && this._currentDirection == Phaser.LEFT || this._wantedDirection == Phaser.LEFT && this._currentDirection == Phaser.RIGHT || this._wantedDirection == Phaser.UP && this._currentDirection == Phaser.DOWN || this._wantedDirection == Phaser.DOWN && this._currentDirection == Phaser.UP) {
			return this._currentDirection;
		} else {
			return this._wantedDirection;
		}
	}
	,SEGMENTS__moveTo: function(x,y) {
		var _g1 = 1;
		var _g = this.SEGMENTS.length | 0;
		while(_g1 < _g) {
			var i = _g1++;
			var segment = this.SEGMENTS.getAt(i);
			var prevX = segment.x;
			var prevY = segment.y;
			segment.x = x;
			segment.y = y;
			x = prevX;
			y = prevY;
		}
		if(this._growOnNextMove) {
			this.SEGMENTS.addSegment(x,y);
			this._growOnNextMove = false;
		}
	}
	,SEGMENTS__moveSpeed: function() {
		return Math.max(150 - this.SEGMENTS.length * 3,50);
	}
	,KEYBOARD__direction: function() {
		if(this.KEYBOARD.left.isDown) {
			return Phaser.LEFT;
		} else if(this.KEYBOARD.right.isDown) {
			return Phaser.RIGHT;
		} else if(this.KEYBOARD.up.isDown) {
			return Phaser.UP;
		} else if(this.KEYBOARD.down.isDown) {
			return Phaser.DOWN;
		} else {
			return 0;
		}
	}
	,KEYBOARD__updateDirection: function() {
		var keyboardDir = this.KEYBOARD__direction();
		if(keyboardDir != 0) {
			this._wantedDirection = keyboardDir;
		}
	}
};
var data_Playfield = function(game,snake,fruit,playfieldSize) {
	Phaser.Group.call(this,game);
	var bounds = this.create(0,0);
	bounds.width = playfieldSize;
	bounds.height = playfieldSize;
	this.snake = snake;
	this.fruit = fruit;
	this.add(fruit);
	this.add(snake);
};
data_Playfield.__name__ = true;
data_Playfield.__super__ = Phaser.Group;
data_Playfield.prototype = $extend(Phaser.Group.prototype,{
});
var data_Snake = function(game,textures) {
	Phaser.Group.call(this,game);
	this._textures = textures;
};
data_Snake.__name__ = true;
data_Snake.__super__ = Phaser.Group;
data_Snake.prototype = $extend(Phaser.Group.prototype,{
	addSegment: function(x,y) {
		this.create(x,y,this.length == 0 ? this._textures.head : this._textures.segment);
	}
});
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if((o instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g11 = 0;
			var _g3 = l;
			while(_g11 < _g3) {
				var i1 = _g11++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = (e1 instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else return o.iterator(); }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
contexts_Collisions.__meta__ = { fields : { SNAKE : { role : null}, FRUIT : { role : null}, SCORE : { role : null}, HISCORE : { role : null}, SCREEN : { role : null}}};
contexts_Movement.__meta__ = { fields : { HEAD : { role : null}, SEGMENTS : { role : null}, KEYBOARD : { role : null}}};
SnakeGame.main();
})();

//# sourceMappingURL=game.js.map